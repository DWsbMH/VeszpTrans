Az elkeszult rendszer szerver-kliens architekturara epul.
Az architektura modellje a \ref{fig_5/architektura}. abran lathato. 
A szerver felelos az adatok kezeleseert, mely a Symfony keretrendszerrel lett megvalositva. 
Az adatokat a Doctrine keretrendszer segitsegevel eri el az adatbazisbol. 
A rendszerben talalhato a szerver, ami egy adminisztracios feladatokat betolto weboldal, es a kliens, egy Android alkalmazas, amely a felhasznalok reszere keszult. 
Az adminisztracios weboldalon az adatok a Twig sablonkezelo segitsegevel jelennek meg. 
Az Android-os kliens a kert adatokat JSON formrmatumban kapja meg. 
A tovabbiakban reszletesen bemutatasra kerul a szerver es a kliens felepitese, mukodese. 

% kell architektura kep meg megtalalni az authenticationprocess kepet

\section{A szerver}
\label{szerverfelepites}

A szerver a Symfony keretrendszer ???-as verziojara epult. 
A beerkezo keres athalad a Symfony tuzfalan, ami elinditja az autentikaciot. 
Ha sikeres volt az autentikacio, a keres a megfelelo kontroller osztalyhoz kerul feldolgozas utan. 

\Picture{Az autentikacio folyamata}{5/authenticationprocess}{width=14cm}
% tuzfal, autentikacio, ilyesmi...

A kontroller osztalyban a beirt URL-hez tartozo metodus hivodik meg. 
Alapesetben ezek az osztalyok a \Highlight{AppBundle\textbackslash Controller} nevterben talalhatoak. 
Az URL-cimek metodusokra valo lekepzese ketfelekepp valosithato meg a Symfony keretrendszer hasznalataval. 

\begin{itemize}
	\item routing.yml fajlban valo definialas
	\item kontroller osztalyokban annotaciokent
\end{itemize}

Az elso opcio akkor elonyos, ha utvonal alapjan akarjuk meghatarozni, hogy mely kodreszlet fog vegrehajtodni a kontrollerek megfelelo kialakitasaval es az annotaciok jo elhelyezesevel. 
Masreszrol a masodik megoldas itt elonyosebb lehet, mert ilyenkor a kodot latva a fajl elhagyasa nelkul meg tudjuk allapitani, hogy milyen esetekben fog a kodreszlet meghivasra kerulni. 
A metodusok annotacioi kozott megszabhatunk kulonbozo parametereket is, melyet az alabbi kodreszlet demonstral:

\begin{lstlisting}
    /**
    * @Route("/{id}/edit", name="line_edit")
    * @Method({"GET", "POST"})
    */
    public function editAction(Request $request, Line $line)
    {
        // ...
    }
\end{lstlisting}

\subsection*{Autentikacio}
\label{authentication}

Az autentikacio a Symfony tuzfal moduljaval tortenik. 
Az ehhez szukseges beallitasok a \Highlight{app\textbackslash config} mappa \Highlight{security.yml} konfiguracios fajljaban talalhatoak. 
A szerverhez jelenleg ket fajta felhasznalo van rendelve, melyek az elobbiekben emlitett fajlban vannak definialva.
A szerver feladatkorebol kiindulva a jelenlegi igenyeket ez a ket felhasznalo kielegiti, ezert nincs szukseg ujabb felhasznalok hozzaadasara. 
Ez azt jelenti, hogy a felhasznalokhoz tartozo jelszavakat is ebben a fajlban taroljuk. 
Biztonsagi szempontokbol kritikus tenyezo, hogy ezek a jelszavak valamilyen modon titkositva legyenek. 
A titkositashoz a bcrypt algoritmust hasznaltam fel. 
A Symfony segitsegevel parancssorbol lehetseges barmilyen jelszot titkositani a bcrypt algoritmussal. 

\begin{lstlisting}
php bin/console security:encode-password
\end{lstlisting}

A parancs futasa kozben bekeri, mi az a jelszo, amit titkositani kell. 
Miutan megadtuk a jelszot, a bemeneten lefuttatja az algoritmust es vegul kiirja a titkositott karaktersorozatot. 
Ezt a szot megadva a fajlban jelszokent, tovabbra is a titkositatlan jelszoval be tud lepni a felhasznalo az oldalra, viszont nem all fent tovabb a veszely, hogy illetektelenek kezebe jutna a jelszo. 

\subsection*{Autorizacio}
\label{authorization}

Az autorizacio folyamata szinten a Symfony tuzfal moduljanak segitsegevel valosult meg. 
Ez a sikeres bejelentkezest kovetoen hajtodik vegre. 
A folyamat celja, hogy a bejelentkezett felhasznalo csak a szamara kijelolt szolgaltatasokat, oldalakat erje el. 
Az elozo pontban emlitett ket felhasznalohoz tehat az alabbi ket szerepkor tartozik:

\begin{itemize}
	\item Latogato
	\item Adminisztrator
\end{itemize}

A latogato szerepkorhoz tartozo felhasznalonak csak az adatbazis-entitasok lekerdezesehez van jogosultsaga. 
Az adminisztratori engedellyel rendelkezo viszont a weboldal minden szolgaltatasahoz hozzafer. 

A szerepkorokhoz hozza lettek rendelve meghatarozott formaju URL cimek. 

\begin{lstlisting}
access_control:
    - { path: /json$, roles: ROLE_USER }
    - { path: ^/, roles: ROLE_ADMIN }
\end{lstlisting}
Az alabbi kodreszlet azt mutatja be, hogy a latogatoi jogkor csak a \Highlight{\/json} vegu URL-cimekhez ad elerest, mig egy adminisztrator minden cimet eler. 
Ugyanezt a funkcionalitast meg lehet valositani szinten annotaciokkal is, de a weboldal kialakitasa miatt celszerubb volt ezt a megoldast valasztani, hisz igy egyetlen fajlban elegendo meghatarozni a hozzaferesi szabalyokat, annotaciok hasznalataval viszont minden kontroller osztalyban egyenkent kellett volna meghatarozni ugyanazokat a szabalyokat.
\subsection*{Adatbazis kapcsolat}
\label{adatbazis}
Az adatbazist a Doctrine keretrendszert hasznalva eri el a szerver. 
Az alkalmazashoz tartozo entitasok helye a \Highlight{AppBundle\textbackslash Entity} nevter. 
Ezek mindegyike egyszeru PHP osztalyok, a felhasznalt keretrendszer alakitja ezeket az adatbazis tablaiva. 
Az osztalyban szereplo adatmezokhoz meg kell adni az annotaciokat, hogy az atalakitas milyen modon tortenjen meg. 
Az entitasok egymas kozti kapcsolatait a kovetkezo annotaciok jelzik:
\begin{itemize}
	\item OneToOne
	\item OneToMany
	\item ManyToOne
\end{itemize}
Az adatbazisban talalhato adatok lekerdezes es objektumba valo alakitasa a \Highlight{Repository} osztalyok segitsegevel tortenik. 
Ezek az osztalyok a Doctrine \Highlight{EntityRepository} osztalyabol szarmaznak, mely mar rendelkezik a legalapvetobb lekerdezesekkel, mint az azonosito vagy valamilyen tulajdonsag alapjan torteno adatlekeres. 
Az osszetettebb lekerdezesekhez a DQL nyelvet hasznaltam fel, mely az entitasok kapcsolatait az entitashoz tartozo osztalyban megadott annotaciok alapjan kezeli. 
Amennyiben az adatbazisbol lekerdezett adatok modosultak, ahhoz, hogy ez a valtozas megmaradjon el kell menteni az adatbazisba. 
A Doctrine keretrendszerben talalhato automatikus megoldas, megpedig az EntityManager osztaly, amely erzekeli a valtozast es elmenti a \Highlight{flush()} metodus hasznalataval. 
Ha uj adatot akarunk az adatbazishoz adni, azt is az EntitiyManager osztallyal tehetjuk meg. 
Az elkeszult uj objektumot parameterkent atadva az osztaly \Highlight{persist()} metodusanak, a Doctrine keretrendszer ugy kezeli a tovabbiakban az objektumot, mintha az az adatbazisbol lekerdezett lenne, es igy a \Highlight{flush()} metodussal az adatbazisba tudja irni. 
\section{Szerver feladatai}
\label{serverjob}
Az alabbiakban bemutatasra kerulnek a szerver fobb feladatai.
\subsection*{Jaratok}
\label{lineinfodetails}
A varosban kozlekedo buszok mas-mas vegpontok kozott kozlekednek. 
Elofordulhat, hogy ugyanolyan szammal ellatott busz ugyanazon vegpontok kozott kozlekedik, de a koztes megallok elterhetnek, vagy a koztes megallok ugyanazok, de a vegpontok masok. 
Ezeknek az informaciok osszefogasara letrehozott \Highlight{LineInfo} entitas felelos. 
Ez az entitas tarolja a ket vegpontot, a kozottuk kozlekedo buszjaratot, es a jarat tipusat. 
A vegpont es a buszjaratok szinten entitasok, az ezek kozott fennallo kapcsolat az \ref{fig_5/lineinfo}. abran lathato. 
\Picture{A jarat entitas kapcsolatai}{5/lineinfo}{width=14cm}
\subsection*{Utvonalak}
\label{linehasstationsdetails}
A buszjaratok utvonaluk bejarasa soran tobb, koztes megallot is erintenek. 
Meg kell hataroznunk, hogy egy adott busz milyen iranyban haladva mely koztes megallokban all meg. 
Ezt a feladatot a \Highlight{LineHasStations} entitas vegzi. 
Az entitas segitsegevel meg tudjuk hatarozni, hogy az elozo pontban vazolt jarat egy peldanyanak a vegpontjain kivul milyen mas allomasai vannak. 
Tovabba taroljuk a koztes megallo utvonalon beluli sorszamat, melybol megallapithato az utvonalon talalhato allomasok helyes sorrendje. 
Minden egyes objektum eseten tarolasra kerul meg, hogy az elozo megallobol milyen gyorsan tudunk eljutni. 
Termeszetesen a busz indulopontjanak ezen attributuma nulla. 
Az \ref{fig_5/linehasstations}. abran megtekintheto milyen kapcsolatokat tartalmaz az utvonal entitas. 
\Picture{A jarathoz kapcsolatai}{5/linehasstations}{width=14cm}
\subsection*{Indulasi idok, kulonleges idopontok}
\label{starttimes}
Utvonaltervezes szempontjabol fontos informacio tovabba, hogy az adott jarat az utvonalan talalhato megalloiba milyen idopontban erkezik meg, tovabba kulonleges alkalmak eseten ezek hogyan valtoznak meg. 
Az indulasi idopontot egy Starttime nevu entitas tartalmazza, melyben tarolodik tovabba az is, hogy ez az indulas mely jaratra vonatkozik, valamint milyen tipusu datum eseten ertetendo. 
A kulonbozo tipusu datumokat kulon entitas tartalmazza. 
Az alkalmazashoz tovabb tartozik egy Holidays entitas is, melyben az olyan, elore nem tervezett idopontokat tartalmazza amelyek befolyasoljak bizonyos jaratok indulasi rendjet es esetleges utvonalat is. 
Az elobbiekben bemutatott entitasok kozotti kapcsolatot a \ref{fig_5/starttimes}. abra mutatja be. 
\Picture{Kulonleges es indulasi idopontok kozotti kapcsolat}{5/starttimes}{width=14cm}

\section{Az Android kliens}
\label{androidclient}
Az alkalmazas fejlesztesehez az Android Studio fejlesztoi kornyezetet hasznaltam.
Az Android Studio a Gradle rendszerre epul, amelynek szamos funkcioja megkonnyiti az Androidos alkalmazasok forditasat.
A Gradle Androidos bovitmenyeben talalhato tobb Android specifikus parancs, amelyek kozul az \Highlight{assemble} paranccsal keszithetjuk el a futtathato es telepitheto allomanyt.
A futtathato fajl elkeszitesehez szukseges informaciokat a build.gradle fajlban adhatjuk meg.
Ebben talalhatoak a szukseges fuggosegek, amiket a Gradle bovitmenye letolt, es belecsomagol az .apk-ba.
Tovabba itt talalhato az applikacio altal tamogatott Android verziok szama.
Az altalam keszitett alkalmazas futtatasahoz legalabb a \Highlight{minSdkVersion 14} verzio szukseges, ami az Android operacios rendszer 4.0 verziojanak felel meg.
Az \Highlight{AndroidManifest.xml} fajl az alkalmazas alapveto jellemzoit tartalmazza.
Ilyen jellemzok tobbek kozott a szukseges engedelyek es a Google Maps-hez tartozo metainformacio.
Az alkalmazas telepitesehez es futtatasahoz szukseg van engedelyekre a felhasznalo reszerol.
Ezek az engedelyek a kovetkezok:
\begin{lstlisting}
<uses-permission android:name="android.permission.INTERNET" /> 
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
\end{lstlisting}

Az elso hozzaferes az Internettel valo kommunikaciohoz szukseges.
Szuksegunk van tovabba olyan engedelyre amivel a Sajat pozicio lekerheto es engedelyezheto a GPS a telefonon.
Mivel az alkalmazasnak szuksege van Internet hozzaferesre az adatok letoltesehez, ezert az alkalmazas engedelyt ker a telefon halozati allapotanak lekeresehez is.

\subsection*{Helyi adatbazis}
\label{localdatabase}
Fontos szempont volt helyi adatbazist letrehozni, mivel az alkalmazas es a szerver kozott folyamatosan felepulo kapcsolat sok eroforrast igenyel.
Tovabba az olyan eseteknel, amikor a keszulek nincs halozatra kapcsolva, akkor nem erne el a szervert, igy nem toltodnenek le a mukodesehez szukseges adatok.
Ezek kovetkezteben szukseg volt arra, hogy az applikacio offline uzemmodban is kepes legyen funkcionalisan mukodni.

Megvizsgaltam tobb Android platformhoz elerheto ORM (object-relational mapping vagyis objektum-relacios lekepezes) keretrendszert, ezen belul is az ORMLite keretrendszert. 
Az ORMLite akkor elonyos, ha nem letezik adatbazis sema, amihez alkalmazkodnia kell.
Mivel az alkalmazas eseteben mar a szerver oldalon kialakitasra kerult egy sema, emiatt a keretrendszer hasznalata nehezkes volt.
%MATE: azota csinalt az Android sajat adatbazis absztrakcios framework-ot, ezt nem probaltam semennyire, mennyire emlitsem meg a szakdogaban?
Ebben a kontextusban szukseges volt, hogy manualisan szemelyre szabhassam a helyi adatbazis semajat, igy vegul a nativ SQL utasitok hasznalata mellett dontottem.

A helyi adatbazis-kezelo rendszer az SQLite, amely az Android operacios rendszerbe gyarilag beepitett adatabazis-kezelo motor.
Mivel az SQLite relacios adatbazis, ezert a kommunikacio szimpla SQL utasitasokkal tortenik.
Az applikacio sikeres mukodesehez szukseges egy \Highlight{SQLiteOpenHelper} osztalybol orokoltetett osztaly, amelyben az adatbazis nevet, verziojat es az adatbazis letrejottekor vegrehajtando utasitasokat taroljuk.
Az ososztalybol ketto metodust kotelezo implementalni, az onCreate es az onUpgrade metodust.
Az onCreate metodus segitsegevel van lehetoseg tablakat letrehozni az eppen elkeszult adatbazisba, amit az alabbi kodreszlet szemleltet.
\begin{lstlisting}
@Override
public void onCreate(SQLiteDatabase sqLiteDatabase) {
	try {
		sqLiteDatabase.execSQL(DateTypeEntry.CREATETABLE);
		/* Create other tables similar to the above one. */
	} catch (SQLiteException e) { /*...*/ }
}
\end{lstlisting}
Ugyanakkor az onUpgrade metodus abban az esetben fut le, ha megnoveltuk az adatbazis verziojat.
Ez a verzioszam novekedes azt jelzi, hogy olyan valtozas tortent az adatbazisban, amely visszafele nem kompatibilis, es egy transzformacio szukseges a regi es az uj sema kozott.
Az \Highlight{SQLiteOpenHelper} osztaly az SQL utasitasokat tranzakcionalisan hatja vegre.
Egy tranzakcio tartalmazhat tobb SQL utasitast is, amelyek vegrehajtasa egyszerre tortenik.
Ha egy SQL utasitas sikertelen, akkor az osszes utasitas visszavonasra kerul.

Az adatbazis minden tablajahoz egy statikus osztaly lett letrehozva, melyek egy DatabaseContract nevu osztalyban tarolodnak.
Minden belso osztaly implementalja a BaseColumns osztalyt, melynek koszonhetoen megkapjak az egyedi azonositasra hasznalatos  \_id mezot.
Erre egy pelda az alabbi kodreszletben lathato.
A tovabbi attributumokat is implementalasra kerultek az adott osztalyokban, majd a mezok alapjan elkeszult a tabla letrehozasahoz szukseges SQL parancs.
\begin{lstlisting}
static class DateTypeEntry implements BaseColumns{
	static final String TABLE_NAME = "date_type";
	static final String COLUMN_NAME_TYPE_NAME = "type_name";
	static final String COLUMN_NAME_ENABLED = "enabled";
	static final String CREATETABLE = "CREATE TABLE IF NOT EXISTS "+ TABLE_NAME+"( `"+_ID+"` INTEGER PRIMARY KEY NOT NULL, `"+COLUMN_NAME_TYPE_NAME+"` TEXT NOT NULL, `"+COLUMN_NAME_ENABLED+"` INTEGER DEFAULT 1);";
}
\end{lstlisting}

Az applikacio lokalis adatbazisaban levo adatok POJO-ban tarolodnak, minden tablahoz kulon POJO tartozik.
A POJO egy olyan Java objektum, amely nem rendelkezik specialis tulajdonsaggal.

Ahhoz, hogy az alacsonyabb szintu SQL utasitasok elkulonuljenek az uzleti logikatol, letrehoztam egy \Highlight{DataManager} nevu absztrakt osztalyt, melynek tipus parametere egy POJO objektum. 
Mivel az osztaly absztrakt - igy nem peldanyosithato - ezert ebben az osztalyban kaptak helyet az olyan metodusok, melyek minden tipusu POJO-ra altalanos ervenyesseguek. 
Az alabbi kodreszletben a DataManager osztaly implementacioja lathato, ahol a createOrUpdate es a queryForAll metodusok az adatbazis tablainak kezeleseert felelosek.
\begin{lstlisting}
public abstract class DataManager<T> {	
    DatabaseHelper helper;
	
	/* ... */
    public abstract void createOrUpdate(T data);
    public abstract List<T> queryForAll();
}
\end{lstlisting} 
Ebbol az osztalybol szarmaznak a specifikus osztalyok, melyeken keresztul adott tipusu POJO-k kerulnek lementesre vagy visszakerdezesre a helyi adatbazisbol.
Az ososztalyban talalhato metodusokat mindenkepp implementalnia kell minden szarmaztatott osztalynak. 
Az olyan funkcionalitasok eseten - amelyek nem minden POJO eseten voltak ertelmezhetoek - a specifikus osztalyban kerultek definialasra.
Az alkalmazas mindenhol ezeket a manager osztalyokat hasznalja, ahol az adatbazissal valo interakcio szukseges.

\subsection*{Szerver-kliens kapcsolat}
\label{serverclient}
A helyi adatbazisban talalhato adatok csak egy adott ido-intervallumban ervenyesek, a menetrend valtoztatasaval ervenyuket vesztik. 
Ezert bizonyos idokozonkent frissiteni kell a benne szereplo informaciokat. 
Az adatok aktualizalasa az alkalmazas inditasakor tortenik, erre szolgal a korabban bemutatott szerver, ahonnan az alkalmazas az aktualis informaciokat kapja.
A szerver REST uzenetekkel valaszol a beerkezo keresekre.
A kommunikaciot a Retrofit nevu REST klienssel oldottam meg, melynek segitsegevel konnyu a szervernek kereseket kuldeni.
A \Highlight{NetworkManager} osztaly kepes lekerdezni, hogy az adott eszkoz rendelkezik-e jelenleg barmilyen internet eleressel. 
Ha a keszulek nem rendelkezik internet eleressel, akkor csak a helyi adatbazist hasznalja.
Ellenkezo esetben pedig elkezdodik az adatok frissitese az applikacio elinditasaval.
A minel kisebb adathasznalat erdekeben a kliens tarolja, hogy mikor tortent az utolso frissites. 
Az applikacio inditaskor elkuldi a legutolso frissitesi datumot a szervernek, a szerver pedig csak azokat az adatokat kuldi vissza, amelyek ujabbak, mint a kapott idopont.
Miutan az adatok aktualizalasa sikeresen megtortent, a frissites idoponja felulirasra kerul a helyi adatbazisban.
Az IDownloader interfeszt a A \Highlight{BaseDownloader} absztrakt osztaly implementalja, melynek konstruktoraban kerulnek inicializalasra a Retrofit szamara szukseges osztalyok.
Lehetosegunk van minden kerest szemelyre szabni. 
Ezt felhasznalva juttatjuk el a szerver szamara a felhasznalo azonositasara szolgalo adatokat es a legutolso frissitesi idopontot.
Az IDownloader interfesz egyetlen metodus-definiciot tartalmaz:
\begin{lstlisting}
public interface IDownloader {
    void download();
}
\end{lstlisting}
A \Highlight{BaseDownloader} osztaly tartalmaz meg egy saveToDatabase metodust, amely az adatok helyi adatbazisba torteno lementesere alkalmas.
A \Highlight{BaseDownloader} osztalybol szarmaztatott gyerekosztalyok implementaljak az elozoekben emlitett ket metodust.

A Retrofit konfiguralasa soran egy interfesz kerult megvalositasra, amelyben metodus-definicio formajaban felsorolasra kerulnek azok a hivasok, amelyeket a Retrofit kepes vegrehajtani.
\begin{lstlisting}
public interface MyApiEndpointInterface {
	/* ... */
	@GET("stations/json")
    Call<List<Stations>> getStations();
}
\end{lstlisting}
A fenti peldan lathato, hogy a megallok eleresehez annotacio formajaban megadasra kerult az eleresi utvonal.
Ennek visszateresi erteke egy olyan lista lesz, amely megallokat tartalmaz.
A listaban talalhato megallokat a Retrofit automatikusan szerializalta ki a szervertol kapott JSON valaszbol.
A szerializalashoz az alabbi entitasban talalhato annotacios konfiguraciot veszi alapul.
\begin{lstlisting}
public class Stations {
	/* ... */
	@SerializedName("lat")
	@Expose
	private double lat;
}
\end{lstlisting}

\subsection*{A felhasznalo felulet kialakitasa}
\label{layout}
A kod karbantarthatosaganak erdekeben a felhasznalo felulet kialakitasa az MVP (Modell-View-Presenter) szoftvertervezesi mintara epul.
Elonye, hogy az uzleti logika elhatarolodik a felhasznalo felulettol, melynek koszonhetoen a kezelofelulet modosithato a logika megvaltoztatasa nelkul.
Az alkalmazas minden kepernyo-nezetehez tartozik egy ugynevezett activity.
Az activity a felhasznalok es az applikacio kozotti legfobb alapelem.
































\newpage
