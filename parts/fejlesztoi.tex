Az elkészült rendszer szerver-kliens architektúrára épült. 
Az architektúra modellje a \ref{fig_5/architektura}. ábrán látható. 
A szerver felelős az adatok kezeléséért, mely a Symfony keretrendszerrel lett megvalósítva. 
Az adatokat a Doctrine keretrendszer segítségével éri el az adatbázisból. 
Jelenleg kétféle kliens tartozik a rendszerhez, egy adminisztrációs feladatokat betöltő weboldal, és egy Android alkalmazás, amely a felhasználók részére készült. 
Az adminisztrációs weboldalon az adatok a Twig sablonkezelő segítségével jelennek meg. 
Az Android-os kliens a kért adatokat JSON formrmátumban kapja meg. 
A továbbiakban részletesen bemutatásra kerül a szerver és a kliensek felépítése, működése. 

\section{A szerver felépítése}
\label{szerverfelepites}

A szerver a Symfony keretrendszer 2.8-as verziójára épült. 
A beérkező kérés áthalad a Symfony tűzfalán, ami elindítja az autentikációt. 
Ha sikeres volt az autentikáció, a kérés a megfelelő kontroller osztályhoz kerül feldolgozás után. 

\Picture{Az autentikáció folyamata}{5/authenticationprocess}{width=14cm}
% tűzfal, autentikáció, ilyesmi...

A kontroller osztályban a beírt URL-hez tartozó metódus hívódik meg. 
Alapesetben ezek az osztályok a \Highlight{AppBundle\textbackslash Controller} névtérben találhatóak. 
Az URL-címek metódusokra való leképzése kétféleképp valósítható meg a Symfony keretrendszer használatával. 

\begin{itemize}
	\item routing.yml fájlban való definiálás
	\item kontroller osztályokban annotációként
\end{itemize}

Az első opció akkor előnyös, ha útvonal alapján akarjuk meghatározni, hogy mely kódrészlet fog végrehajtódni a kontrollerek megfelelő kialakításával és az annotációk jó elhelyezésével. 
Másrészről a második megoldás itt előnyösebb lehet, mert ilyenkor a kódot látva a fájl elhagyása nélkül meg tudjuk állapítani, hogy milyen esetekben fog a kódrészlet meghívásra kerülni. 
A metódusok annotációi között megszabhatunk különböző paramétereket is, melyet az alábbi kódrészlet demonstrál:

\begin{lstlisting}
    /**
    * @Route("/{id}/edit", name="line_edit")
    * @Method({"GET", "POST"})
    */
    public function editAction(Request $request, Line $line)
    {
        // ...
    }
\end{lstlisting}

\subsection*{Autentikáció}
\label{authentication}

Az autentikáció a Symfony tűzfal moduljával történik. 
Az ehhez szükséges beállítások a \Highlight{app\textbackslash config} mappa \Highlight{security.yml} konfigurációs fájljában találhatóak. 
A szerverhez jelenleg két fajta felhasználó van rendelve, ezek bele vannak égetve ebbe a fájlba. 
A szerver feladatköréből kiindulva a jelenlegi igényeket ez a két felhasználó kielégíti, mivel szükség újabb felhasználók hozzáadására. 
Ez azt jelenti, hogy a felhasználókhoz tartozó jelszavakat is ebben a fájlban tároljuk. 
Biztonsági szempontokból kritikus tényező, hogy ezek a jelszavak valamilyen módon titkosítva legyenek. 
A titkosításhoz a bcrypt algoritmust használtam fel. 
A Symfony segítségével parancssorból lehetséges bármilyen jelszót titkosítani a bcrypt algoritmussal. 

\begin{lstlisting}
php bin/console security:encode-password
\end{lstlisting}

A parancs futása közben bekéri, mi az a jelszó, amit titkosítani kell. 
Miután megadtuk a jelszót, a bemeneten lefuttatja az algoritmust és végül kiírja a titkosított karaktersorozatot. 
Ezt a szót megadva a fájlban jelszóként, továbbra is a titkosítatlan jelszóval be tud lépni a felhasználó az oldalra, viszont nem áll fent tovább a veszély, hogy illetéktelenek kezébe jutna a jelszó. 

\subsection*{Autorizáció}
\label{authorization}

Az autorizáció folyamata szintén a Symfony tűzfal moduljának segítségével valósult meg. 
Ez a sikeres bejelentkezést követően hajtódik végre. 
A folyamat célja, hogy a bejelentkezett felhasználó csak a számára kijelölt szolgáltatásokat, oldalakat érje el. 
Az előző pontban említett két felhasználóhoz tehát az alábbi két szerepkör tartozik:

\begin{itemize}
	\item Látogató
	\item Adminisztrátor
\end{itemize}

A látogató szerepkörhöz tartozó felhasználónak csak az adatbázis-entitások lekérdezéséhez van jogosultsága. 
Az adminisztrátori engedéllyel rendelkező viszont a weboldal minden szolgáltatásához hozzáfér. 

A szerepkörökhöz hozzá lettek rendelve meghatározott formájú URL címek. 

\begin{lstlisting}
access_control:
    - { path: /json$, roles: ROLE_USER }
    - { path: ^/, roles: ROLE_ADMIN }
\end{lstlisting}

Az alábbi kódrészlet azt mutatja be, hogy a felhasználói jogkör csak a \Highlight{\/json} végű URL-címekhez ad elérést, míg egy adminisztrátor minden címet elér. 
Ugyanezt a funkcionalitást meg lehet valósítani szintén annotációkkal is, de a weboldal kialakítása miatt célszerűbb volt ezt a megoldást választani, hisz így egyetlen fájlban elegendő meghatározni a hozzáférési szabályokat, annotációk használatával viszont minden kontroller osztályban egyenként kellett volna meghatározni ugyanazokat a szabályokat.

\subsection*{Adatbázis kapcsolat}
\label{adatbazis}

Az adatbázist a Doctrine keretrendszert használva éri el a szerver. 
Az alkalmazáshoz tartozó entitások helye a \Highlight{AppBundle\textbackslash Entity} névtér. 
Ezek mindegyike egyszerű PHP osztályok, a felhasznált keretrendszer alakítja ezeket az adatbázis tábláivá. 
Az osztályban szereplő adatmezőkhöz meg kell adni az annotációkat, hogy az átalakítás milyen módon történjen meg. 
Az entitások egymás közti kapcsolatait a következő annotációk jelzik:

\begin{itemize}
	\item OneToOne
	\item OneToMany
	\item ManyToOne
\end{itemize}

Az adatbázisban található adatok lekérdezés és objektumba való alakítása a \Highlight{Repository} osztályok segítségével történik. 
Ezek az osztályok a Doctrine \Highlight{EntityRepository} osztályából származnak, mely már rendelkezik a legalapvetőbb lekérdezésekkel, mint az azonosító vagy valamilyen tulajdonság alapján történő adatlekérés. 
Az összetettebb lekérdezésekhez a DQL nyelvet használtam fel, mely az entitások kapcsolatait az entitáshoz tartozó osztályban megadott annotációk alapján kezeli. 

Amennyiben az adatbázisból lekérdezett adatok módosultak, ahhoz, hogy ez a változás megmaradjon el kell menteni az adatbázisba. 
Szerencsére a Doctrine keretrendszernek van erre automatikus eszköze, mégpedig az EntityManager osztály, mely érzékeli a változást és elmenti a \Highlight{flush()} metódus használatával. 
Ha új adatot akarunk az adatbázishoz adni, azt is az EntitiyManager osztállyal tehetjük meg. 
Az elkészült új objektumot paraméterként átadva az osztály \Highlight{persist()} metódusának, a Doctrine keretrendszer úgy kezeli a továbbiakban az objektumot, mintha az az adatbázisból lekérdezett lenne, és így a \Highlight{flush()} metódussal az adatbázisba tudja írni. 

\section{Szerver feladatai}
\label{serverjob}

A alábbiakban bemutatásra kerülnek a szerver főbb feladatai.

\subsection*{Járatok}
\label{lineinfodetails}

A városban közlekedő buszok más-más végpontok között közlekednek. 
Előfordulhat, hogy ugyanolyan számmal ellátott busz ugyanazon végpontok között közlekedik, de a köztes megállók között eltérhet, vagy a köztes megállók ugyanazok, de a végpontok mások. 
Olyan helyzet is előfordulhat, hogy a két végpont megegyezik. 
Ezeknek az információk összefogására létrehozott \Highlight{LineInfio} entitás felelős. 
Ez az entitás tárolja a két végpontot, a közöttük közlekedő buszjáratot, és a járat típusát. 
A végpont és a buszjáratok szintén entitások, az ezek között fennálló kapcsolat az \ref{fig_5/lineinfo}. ábrán látható. 

\Picture{A járat entitás kapcsolatai}{5/lineinfo}{width=14cm}

\subsection*{Útvonalak}
\label{linehasstationsdetails}

A buszjáratok útvonaluk bejárása során több, köztes megállót is érintenek. 
Meg kell határoznunk, hogy egy adott busz milyen irányban haladva mely köztes megállókban áll meg. 
Ezt a feladatot a \Highlight{LineHasStations} entitás végzi. 
Az entitás segítségével meg tudjuk határozni, hogy az előző pontban vázolt járat egy példányának a végpontjain kívül milyen más állomásai vannak. 
Továbbá tároljuk a köztes megálló útvonalon belüli sorszámát, melyből megállapítható az útvonalon található állomások helyes sorrendje. 
Minden egyes objektum esetén tárolásra kerül még, hogy az előző megállóból milyen gyorsan tudunk eljutni. 
Természetesen a busz indulópontjának ezen attribútuma nulla. 

Az \ref{fig_5/linehasstations}. ábrán megtekinthető milyen kapcsolatokat tartalmaz az útvonal entitás. 

\Picture{A járathoz kapcsolatai}{5/linehasstations}{width=14cm}

\subsection*{Indulási idők, különleges időpontok}
\label{starttimes}

Útvonaltervezés szempontjából fontos információ továbbá, hogy az adott járat az útvonalán található megállóiba milyen időpontban érkezik meg, továbbá különleges alkalmak esetén ezek hogyan változnak meg. 
Az indulási időpontot egy Starttime nevű entitás tartalmazza, melyben tárolódik továbbá az is, hogy ez az indulás mely járatra vonatkozik, valamint milyen típusú dátum esetén értetendő. 
A különböző típusú dátumokat külön entitás tartalmazza. 
Az alkalmazáshoz tovább tartozik egy Holidays entitás is, melyben az olyan, előre nem tervezett időpontokat tartalmazza amelyek befolyásolják bizonyos járatok indulási rendjét és esetleges útvonalát is. 
Az előbbiekben bemutatott entitások közötti kapcsolatot a \ref{fig_5/starttimes}. ábra mutatja be. 

\Picture{Különleges és indulási időpontok közötti kapcsolat}{5/starttimes}{width=14cm}