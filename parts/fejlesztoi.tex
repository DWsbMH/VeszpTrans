Az elkészült rendszer szerver-kliens architekturára épül.
Az architektúra modellje \aref{fig_5/architektura}.\ ábrán látható. 
A szerver felelős az adatok kezeléséért, mely a Symfony keretrendszerrel lett megvalósítva. 
\Picture{A program architektúrája}{5/architektura}{width=12cm}
Az adatokat a Doctrine keretrendszer segítségével éri el az adatbázisból. 
A rendszerben található a szerver, ami egy adminisztrációs feladatokat betöltő weboldal, és a kliens, egy Android alkalmazás, amely a felhasználók részére készült. 
Az adminisztrációs weboldalon az adatok a Twig sablonkezelő segítségével jelennek meg. 
Az Android-os kliens a kért adatokat JSON formrmátumban kapja meg. 
A továbbiakban részletesen bemutatásra kerül a szerver és a kliens felépítése, működése. 


\section{A szerver}
\label{szerverfelepites}
A szerver a Symfony\cite{symfonyframework} keretrendszer 2.8-as verziójára épült. 
A beérkező kérés áthalad a Symfony tűzfalán, ami elindítja az autentikációt, melynek folyamata \aref{fig_5/authenticationprocess}.\ ábrán látható. 
Ha sikeres volt az autentikáció, a kérés a megfelelő kontroller osztályhoz kerül feldolgozás után. 

\Picture{Az autentikáció folyamata}{5/authenticationprocess}{width=12cm}

A kontroller osztályban a beírt URL-hez tartozó metódus hívódik meg. 
Alapesetben ezek az osztályok a \Highlight{AppBundle\textbackslash Controller} névtérben találhatóak. 
Az URL-címek metódusokra való leképzése kétféleképp valósítható meg a Symfony keretrendszer használatával. 

\begin{itemize}
	\item routing.yml fájlban való definiálás
	\item kontroller osztályokban annotációként
\end{itemize}

Az első opció akkor előnyös, ha útvonal alapján akarjuk meghatározni, hogy mely kódrészlet fog végrehajtódni a kontrollerek megfelelő kialakításával és az annotációk jó elhelyezésével. 
Másrészről a második megoldás itt előnyösebb lehet, mert ilyenkor a kódot látva a fájl elhagyása nélkül meg tudjuk állapítani, hogy milyen esetekben fog a kódrészlet meghívásra kerülni. 
A metódusok annotációi között megszabhatunk különböző paramétereket is, melyet az alábbi kódrészlet demonstrál:

\begin{lstlisting}
    /**
    * @Route("/{id}/edit", name="line_edit")
    * @Method({"GET", "POST"})
    */
    public function editAction(Request $request, Line $line)
    {
        // ...
    }
\end{lstlisting}

\subsection*{Autentikáció}
\label{authentication}

Az autentikáció a Symfony tűzfal moduljával történik. 
Az ehhez szükséges beállítások a \Highlight{app\textbackslash config} mappa \Highlight{security.yml} konfigurációs fájljában találhatóak. 
A szerverhez jelenleg két fajta felhasználó van rendelve, melyek az előbbiekben említett fájlban vannak definiálva.
A szerver feladatköréből kiindulva a jelenlegi igényeket ez a két felhasználó kielégíti, ezért nincs szükség újabb felhasználók hozzáadására. 
Ez azt jelenti, hogy a felhasználókhoz tartozó jelszavakat is ebben a fájlban tároljuk. 
Biztonsági szempontokból kritikus tényező, hogy ezek a jelszavak valamilyen módon titkosítva legyenek. 
A titkosításhoz a \Highlight{bcrypt} algoritmust használtam fel. 
A Symfony segítségével parancssorból lehetséges bármilyen jelszót titkosítani a \Highlight{bcrypt} algoritmussal. 

\begin{lstlisting}
php bin/console security:encode-password
\end{lstlisting}

A parancs futása közben bekéri, mi az a jelszó, amit titkosítani kell. 
Miután megadtuk a jelszót, a bemeneten lefuttatja az algoritmust és végül kiírja a titkosított karaktersorozatot, azaz a jelszóhoz tartozó hash-t.
Ezt a hash-t megadva a fájlban, továbbra is a titkosítatlan jelszóval be tud lépni a felhasználó az oldalra, viszont nem áll fent tovább a veszély, hogy illetéktelenek kezébe jutna a jelszó. 

\subsection*{Autorizáció}
\label{authorization}

Az autorizáció folyamata szintén a Symfony tűzfal moduljának segítségével valósult meg. 
Ez a sikeres bejelentkezést követően hajtódik végre. 
A folyamat célja, hogy a bejelentkezett felhasználó csak a számára kijelölt szolgáltatásokat, oldalakat érje el. 
Az előző pontban említett két felhasználóhoz tehát az alábbi két szerepkör tartozik:

\begin{itemize}
	\item Látogató
	\item Adminisztrátor
\end{itemize}

A látogató szerepkörhöz tartozó felhasználónak csak az adatbázis-entitások lekérdezéséhez van jogosultsága. 
Az adminisztrátori engedéllyel rendelkező viszont a weboldal minden szolgáltatásához hozzáfér. 

A szerepkörökhöz hozzá lettek rendelve meghatározott formájú URL címek. 

\begin{lstlisting}
access_control:
    - { path: /json$, roles: ROLE_USER }
    - { path: ^/, roles: ROLE_ADMIN }
\end{lstlisting}
Az alábbi kódrészlet azt mutatja be, hogy a látogatói jogkör csak a \Highlight{\/json} végű URL-címekhez ad elérést, míg egy adminisztrátor minden címet elér. 
Ugyanezt a funkcionalitást meg lehet valósítani szintén annotációkkal is, de a weboldal kialakítása miatt célszerűbb volt ezt a megoldást választani, hisz így egyetlen fájlban elegendő meghatározni a hozzáférési szabályokat, annotációk használatával viszont minden kontroller osztályban egyenként kellett volna meghatározni ugyanazokat a szabályokat.
\subsection*{Adatbázis kapcsolat}
\label{adatbazis}
Az adatbázist a Doctrine keretrendszert használva éri el a szerver. 
Az alkalmazáshoz tartozó entitások helye a \Highlight{AppBundle\textbackslash Entity} névtér. 
Ezek mindegyike egyszerű PHP osztályok, a felhasznált keretrendszer alakítja ezeket az adatbázis tábláivá. 
Az osztályban szereplő adatmezőkhöz meg kell adni az annotációkat, hogy az átalakítás milyen módon történjen meg. 
Az entitások egymás közti kapcsolatait a következő annotációk jelzik:
\begin{itemize}
	\item OneToOne
	\item OneToMany
	\item ManyToOne
\end{itemize}
Az adatbázisban található adatok lekérdezés és objektumba való alakítása a \Highlight{Repository} osztályok segítségével történik. 
Ezek az osztályok a Doctrine \Highlight{EntityRepository} osztályából származnak, mely már rendelkezik a legalapvetőbb lekérdezésekkel, mint az azonosító vagy valamilyen tulajdonság alapján történő adatlekérés. 
Az összetettebb lekérdezésekhez a DQL nyelvet használtam fel, mely az entitások kapcsolatait az entitáshoz tartozó osztályban megadott annotációk alapján kezeli. 
Amennyiben az adatbázisból lekérdezett adatok módosultak, ahhoz, hogy ez a változás megmaradjon el kell menteni az adatbázisba. 
A Doctrine keretrendszerben található automatikus megoldás, mégpedig az EntityManager osztály, amely érzékeli a változást és elmenti a \Highlight{flush()} metódus használatával. 
Ha új adatot akarunk az adatbázishoz adni, azt is az EntitiyManager osztállyal tehetjük meg. 
Az elkészült új objektumot paraméterként átadva az osztály \Highlight{persist()} metódusának, a Doctrine keretrendszer úgy kezeli a továbbiakban az objektumot, mintha az az adatbázisból lekérdezett lenne, és így a \Highlight{flush()} metódussal az adatbázisba tudja írni. 
\section{Szerver feladatai}
\label{serverjob}
Az alábbiakban bemutatásra kerülnek a szerver főbb feladatai.
\subsection*{Járatok}
\label{lineinfodetails}
A városban közlekedő buszok más-más végpontok között közlekednek. 
Előfordulhat, hogy ugyanolyan számmal ellátott busz ugyanazon végpontok között közlekedik, de a köztes megállók eltérhetnek, vagy a köztes megállók ugyanazok, de a végpontok mások. 
Ezeknek az információk összefogására létrehozott \Highlight{LineInfo} entitás felelős. 
Ez az entitás tárolja a két végpontot, a közöttük közlekedő buszjáratot, és a járat típusát. 
A végpont és a buszjáratok szintén entitások, az ezek között fennálló kapcsolat az \ref{fig_5/lineinfo}. ábrán látható. 
\Picture{A járat entitás kapcsolatai}{5/lineinfo}{width=14cm}
\subsection*{Útvonalak}
\label{linehasstationsdetails}
A buszjáratok útvonaluk bejárása során több, köztes megállót is érintenek. 
Meg kell határoznunk, hogy egy adott busz milyen irányban haladva mely köztes megállókban áll meg. 
Ezt a feladatot a \Highlight{LineHasStations} entitás végzi. 
Az entitás segítségével meg tudjuk határozni, hogy az előző pontban vázolt járat egy példányának a végpontjain kívül milyen más állomásai vannak. 
Továbbá tároljuk a köztes megálló útvonalon belüli sorszámát, melyből megállapítható az útvonalon található állomások helyes sorrendje. 
Minden egyes objektum esetén tárolásra kerül még, hogy az előző megállóból milyen gyorsan tudunk eljutni. 
Természetesen a busz indulópontjának ezen attribútuma nulla. 
\Aref{fig_5/linehasstations}.\ ábrán megtekinthető milyen kapcsolatokat tartalmaz az útvonal entitás. 
\Picture{A járathoz kapcsolatai}{5/linehasstations}{width=14cm}
\subsection*{Indulási idők, különleges időpontok}
\label{starttimes}
Útvonaltervezés szempontjából fontos információ továbbá, hogy az adott járat az útvonalán található megállóiba milyen időpontban érkezik meg, továbbá különleges alkalmak esetén ezek hogyan változnak meg. 
Az indulási időpontot egy \Highlight{Starttime} nevű entitás tartalmazza, melyben tárolódik továbbá az is, hogy ez az indulás mely járatra vonatkozik, valamint milyen típusú dátum esetén értetendő. 
A különböző típusú dátumokat külön entitás tartalmazza. 
Az alkalmazáshoz tovább tartozik egy \Highlight{Holidays} entitás is, melyben az olyan, előre nem tervezett időpontokat tartalmazza amelyek befolyásolják bizonyos járatok indulási rendjét és esetleges útvonalát is. 
Az előbbiekben bemutatott entitások közötti kapcsolatot a \ref{fig_5/starttimes}. ábra mutatja be. 
\Picture{Különleges és indulási időpontok közötti kapcsolat}{5/starttimes}{width=14cm}

\section{Az Android kliens}
\label{androidclient}
Az alkalmazás fejlesztéséhez az Android Studio fejlesztői környezetet használtam.
Az Android Studio a Gradle automatikus projektépítő rendszert használja alapértelmezettként, amelynek számos funkciója megkönnyíti az Androidos alkalmazások fordítását.
A Gradle Androidos bővítményében található több Android specifikus parancs, amelyek közül az \Highlight{assemble} paranccsal készíthetjük el a futtatható és telepíthető állományt.
A futtatható fájl elkészítéséhez szükséges információkat a build.gradle fájlban adhatjük meg.
Ebben találhatóak a szükséges függőségek, amiket a Gradle bővítménye letölt, és belecsomagol az .apk-ba.
Továbbá itt található az applikáció által támogatott Android verziók száma.
Az általam készített alkalmazás futtatásához legalább a \Highlight{minSdkVersion 14} verzió szükséges, ami az Android operációs rendszer 4.0 verziójának felel meg.
Az \Highlight{AndroidManifest.xml} fájl az alkalmazás alapvető jellemzőit tartalmazza.
Ilyen jellemzők többek között a szükséges engedélyek és a Google Maps-hez tartozó metainformáció.
Az alkalmazás telepítéséhez és futtatásához szükség van engedélyekre a felhasználó részéről.
Ezek az engedélyek a következők:
\begin{lstlisting}
<uses-permission android:name="android.permission.INTERNET" /> 
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
\end{lstlisting}

Az első hozzáférés az Internettel való kommunikációhoz szükséges.
Szükségünk van továbbá olyan engedélyre amivel a Saját pozíció lekérhető és engedélyezhető a GPS a telefonon.
Mivel az alkalmazásnak szüksége van Internet hozzáférésre az adatok letöltéséhez, ezért az alkalmazás engedélyt kér a telefon hálózati állapotának lekéréséhez is.

\subsection*{Helyi adatbázis}
\label{localdatabase}
Fontos szempont volt helyi adatbázist létrehozni, mivel az alkalmazás és a szerver között folyamatosan felépülő kapcsolat sok erőforrást igényel.
Továbbá az olyan eseteknél, amikor a készülék nincs hálózatra kapcsolva, akkor nem érné el a szervert, így nem töltődnének le a működéséhez szükséges adatok.
Ezek következtében szükség volt arra, hogy az applikáció offline üzemmódban is képes legyen funkcionálisan működni.

Megvizsgáltam több Android platformhoz elérhető ORM (object-relational mapping vagyis objektum-relációs leképezés) keretrendszert, ezen belül is az ORMLite keretrendszert. 
Az ORMLite akkor előnyös, ha nem létezik adatbázis séma, amihez alkalmazkodnia kell.
Mivel az alkalmazás esetében már a szerver oldalon kialakításra került egy séma, emiatt a keretrendszer használata nehézkes volt.
Ebben a kontextusban szükséges volt, hogy manuálisan személyre szabhassam a helyi adatbázis sémáját, így végül a natív SQL utasítok használata mellett döntöttem.

Az androidos kliens implementálását követően kiadásra került több architekturális felépítést segítő könyvtár.
Ezek közül a \Highlight{Room} nevű könyvtár az adatok tárolásáért felel.
A \Highlight{Room} egy adatbázis absztrakciós könyvtár, amely elrejti az alatta található adattárolós részleteit.
Fordítási időben validálja az SQL lekérdezéseket, így ha ezek között található olyan, amely nem felel meg az adatbázis sémának, fordítási hibaként jeleníti meg futás idejű hiba helyett.

A helyi adatbázis-kezelő rendszer az SQLite, amely az Android operációs rendszerbe gyárilag beépített adatabázis-kezelő motor.
Mivel az SQLite relációs adatbázis, ezért a kommunikáció szimpla SQL utasításokkal történik.
Az applikáció sikeres működéséhez szükséges egy \Highlight{SQLiteOpenHelper} osztályból örököltetett osztály, amelyben az adatbázis nevét, verzióját és az adatbázis létrejöttekor végrehajtandó utasításokat tároljuk.
Az ősosztályból kettő metódust kötelező implementálni, az onCreate és az onUpgrade metódust.
Az onCreate metódus segítségével van lehetőség táblákat létrehozni az éppen elkészült adatbázisba, amit az alábbi kódrészlet szemléltet.
\begin{lstlisting}
@Override
public void onCreate(SQLiteDatabase sqLiteDatabase) {
	try {
		sqLiteDatabase.execSQL(DateTypeEntry.CREATETABLE);
		/* Create other tables similar to the above one. */
	} catch (SQLiteException e) { /*...*/ }
}
\end{lstlisting}
Ugyanakkor az onUpgrade metódus abban az esetben fut le, ha megnöveltük az adatbázis verzióját.
Ez a verziószám növekedés azt jelzi, hogy olyan változás történt az adatbázisban, amely visszafele nem kompatibilis, és egy transzformáció szükséges a régi és az új séma között.
Az \Highlight{SQLiteOpenHelper} osztály az SQL utasításokat tranzakcionálisan hatja végre.
Egy tranzakció tartalmazhat több SQL utasítást is, amelyek végrehajtása egyszerre történik.
Ha egy SQL utasítás sikertelen, akkor az összes utasítás visszavonásra kerül.

Az adatbázis minden táblájához egy statikus osztály lett létrehozva, melyek egy DatabaseContract nevű osztályban tárolódnak.
Minden belső osztály implementálja a BaseColumns osztályt, melynek köszönhetően megkapják az egyedi azonosításra használatos  \_id mezőt.
Erre egy példa az alábbi kódrészletben látható.
A további attribútumokat is implementálásra kerültek az adott osztályokban, majd a mezők alapján elkészült a tábla létrehozásához szükséges SQL parancs.
\begin{lstlisting}
static class DateTypeEntry implements BaseColumns{
	static final String TABLE_NAME = "date_type";
	static final String COLUMN_NAME_TYPE_NAME = "type_name";
	static final String COLUMN_NAME_ENABLED = "enabled";
	static final String CREATETABLE = "CREATE TABLE IF NOT EXISTS "+ TABLE_NAME+"( `"+_ID+"` INTEGER PRIMARY KEY NOT NULL, `"+COLUMN_NAME_TYPE_NAME+"` TEXT NOT NULL, `"+COLUMN_NAME_ENABLED+"` INTEGER DEFAULT 1);";
}
\end{lstlisting}

Az applikáció lokális adatbázisában lévő adatok POJO-ban tárolódnak, minden táblához külön POJO tartozik.
A POJO egy olyan Java objektum, amely nem rendelkezik speciális tulajdonsággal.

Ahhoz, hogy az alacsonyabb szintű SQL utasítások elkülönüljenek az üzleti logikától, létrehoztam egy \Highlight{DataManager} nevű absztrakt osztályt, melynek típus paramétere egy POJO objektum. 
Mivel az osztály absztrakt - így nem példányosítható - ezért ebben az osztályban kaptak helyet az olyan metódusok, melyek minden típusú POJO-ra általános érvényességűek. 
Az alábbi kódrészletben a DataManager osztály implementációja látható, ahol a createOrUpdate és a queryForAll metódusok az adatbázis tábláinak kezeléséért felelősek.
\begin{lstlisting}
public abstract class DataManager<T> {	
    DatabaseHelper helper;
	
	/* ... */
    public abstract void createOrUpdate(T data);
    public abstract List<T> queryForAll();
}
\end{lstlisting} 
Ebből az osztályból származnak a specifikus osztályok, melyeken keresztül adott típusú POJO-k kerülnek lementésre vagy visszakérdezésre a helyi adatbázisból.
Az ősosztályban található metódusokat mindenképp implementálnia kell minden származtatott osztálynak. 
Az olyan funkcionalitások esetén - amelyek nem minden POJO esetén voltak értelmezhetőek - a specifikus osztályban kerültek definiálásra.
Az alkalmazás mindenhol ezeket a manager osztályokat használja, ahol az adatbázissal való interakció szükséges.

\subsection*{Szerver-kliens kapcsolat}
\label{serverclient}
A helyi adatbázisban található adatok csak egy adott idő-intervallumban érvényesek, a menetrend változtatásával érvényüket vesztik. 
Ezért bizonyos időközönként frissíteni kell a benne szereplő információkat. 
Az adatok aktualizálása az alkalmazás indításakor történik, erre szolgál a korábban bemutatott szerver, ahonnan az alkalmazás az aktuális információkat kapja.
A szerver REST üzenetekkel válaszol a beérkező kérésekre.
A kommunikációt a Retrofit nevű REST klienssel oldottam meg, melynek segítségével könnyű a szervernek kéréseket küldeni.
A \Highlight{NetworkManager} osztály képes lekérdezni, hogy az adott eszköz rendelkezik-e jelenleg bármilyen internet eléréssel. 
Ha a készülék nem rendelkezik internet eléréssel, akkor csak a helyi adatbázist használja.
Ellenkező esetben pedig elkezdődik az adatok frissítése az applikáció elindításával.
A minél kisebb adathasználat érdekében a kliens tárolja, hogy mikor történt az utolsó frissítés. 
Az applikáció indításkor elküldi a legutolsó frissítési dátumot a szervernek, a szerver pedig csak azokat az adatokat küldi vissza, amelyek újabbak, mint a kapott időpont.
Miután az adatok aktualizálása sikeresen megtörtént, a frissítés időponja felülírásra kerül a helyi adatbázisban.
Az IDownloader interfészt a A \Highlight{BaseDownloader} absztrakt osztály implementálja, melynek konstruktorában kerülnek inicializálásra a Retrofit számára szükséges osztályok.
Lehetőségünk van minden kérést személyre szabni. 
Ezt felhasználva juttatjuk el a szerver számára a felhasználó azonosítására szolgáló adatokat és a legutolsó frissítési időpontot.
Az IDownloader interfész egyetlen metódus-definíciót tartalmaz:
\begin{lstlisting}
public interface IDownloader {
    void download();
}
\end{lstlisting}
A \Highlight{BaseDownloader} osztály tartalmaz még egy saveToDatabase metódust, amely az adatok helyi adatbázisba történő lementésére alkalmas.
A \Highlight{BaseDownloader} osztályból származtatott gyerekosztályok implementálják az előzőekben említett két metódust.

A Retrofit konfigurálása során egy interfész került megvalósításra, amelyben metódus-definíció formájában felsorolásra kerülnek azok a hívások, amelyeket a Retrofit képes végrehajtani.
\begin{lstlisting}
public interface MyApiEndpointInterface {
	/* ... */
	@GET("stations/json")
    Call<List<Stations>> getStations();
}
\end{lstlisting}
A fenti példán látható, hogy a megállók eléréséhez annotáció formájában megadásra került az elérési útvonal.
Ennek visszatérési értéke egy olyan lista lesz, amely megállókat tartalmaz.
A listában található megállókat a Retrofit automatikusan szerializálta ki a szervertől kapott JSON válaszból.
A szerializáláshoz az alábbi entitásban található annotációs konfigurációt veszi alapul.
\begin{lstlisting}
public class Stations {
	/* ... */
	@SerializedName("lat")
	@Expose
	private double lat;
}
\end{lstlisting}

\subsection*{A felhasználó felület kialakítása}
\label{layout}
A kód karbantarthatóságának érdekében a felhasználói felület kialakítása az MVP (Modell-View-Presenter) szoftvertervezési mintára épül.
Implementálása a \Highlight{Mosby} könyvtár segítségével történt.
Előnye, hogy az üzleti logika elhatárolódik a felhasználó felülettől, melynek köszönhetően a kezelőfelület módosítható a logika megváltoztatása nélkül.
Az alkalmazás minden képernyő-nézetéhez tartozik egy úgynevezett activity.
Az activity a felhasználók és az applikáció közötti legfőbb alapelem.
A Mosby könyvtárban találhatóak előre definiált osztályok és felületek, melyek kiindulási pontként szolgálnak az MVP megvalósításához.
A tervezési minta alkalmazásához létre kell hozni minden activity esetén egy interfészt, melyben definiálásra kerül, hogy milyen műveleteket tud végrehajtani az activity.
Az üzleti logika tényleges megvalósítása a presenter osztályban történik, így ez az aspektus nem lesz kihatással a felhasználói felületre.
A presenter osztályok típusparaméterként megkapják az előzőekben említett felületet.
A létrehozott felületet implementálnia kell az activity-nek, és típusparaméterként meg kell adni mind a felületet, mind a presenter osztályt.
A felület, presenter és activity osztályok mind a könyvtárban található alaposztályok leszármazottjai.
Minden activity-hez tartozik egy .xml kiterjesztésű fájl, mely a felhasználói felület építő elemeit tartalmazza.
A tervezésre lehetőség van az XML fájlban történő szöveges kifejtésre, illetve grafikus felületen keresztül, amelyre drag-and-drop módszerrel helyezhetjük rá az elemeket.
Az előbb bemutatott tervező felület \aref{fig_5/designer}.\ ábrán látható.
\Picture{Google Maps útvonaltervezés}{5/designer}{width=10cm}

\subsection*{Google Maps integráció}
\label{googlemaps}
A Google Maps alkalmazásba való integrációját több előkészületi lépés előzte meg.
Első lépésként a Google Developer weboldalon egy projekt létrehozása szükséges.
A projektben engedélyezésre kerültek azon szolgálatások, amelyek az alkalmazás funkcionalitásához elengedhetetlenek.
Az engedélyezett szolgáltatások használatához az alkalmazásban egy hitelesító kulcsot kötelező megadni, amely a fent említett Google Developer oldalon generálódik. 
Mindezek után minden lehetőség adott a térkép megjelenítésére az alkalmazásban.
Ennek legegyszerűbb módja, ha a \Highlight{SupportMapFragment} osztályt használjuk.
Ez az osztály körülfog egy térképet és automatikusan kezeli annak életciklusát.
Egyszerűen megjeleníthető a kívánt activity-ben, az XML fájlhoz az alábbiakban bemutatott módon kell hozzáadni:
\begin{lstlisting}
<fragment
	android:id="@+id/map"
	android:name="com.google.android.gms.maps.SupportMapFragment"
	android:layout_width="match_parent>
	android:layout_height="match_parent"
/>
\end{lstlisting}

Ahhoz, hogy a térkép dinamikusan módosítható legyen, egy \Highlight{GoogleMap} példányra van szükség.
A \Highlight{SupportMapFragment} osztályon a \Highlight{getMapAsync(OnMapReadyCallback)} metódust meghívva az osztály inicializálja a térképet.
Miután ez megtörtént, a metódus paramétereként átadott \Highlight{OnMapReadyCallback} felületen meghívódik az \Highlight{onMapReady} metódust, ami egy \Highlight{GoogleMap} példányt biztosít.
A \Highlight{OnMapReadyCallback} felület lehet külön osztály, de akár egy activity is implementálhatja azt, így amikor a példány elérhető, azonnal interakcióba léphetünk vele az activity-ben.
Az előzőekben bemutatott folyamat implementációja az alábbiakban látható:
\begin{lstlisting}
abstract class BaseMapActivity<V extends MvpView, P extends BaseMapPresenter<V>> extends MvpActivity<V, P> implements OnMapReadyCallback {

    void getMapFragment() {
        SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager().findFragmentById(R.id.map);
        mapFragment.getMapAsync(this);
    }

    @Override
    public void onMapReady(GoogleMap googleMap) {
        presenter.onMapReady(googleMap);
    }

}
\end{lstlisting}
A \Highlight{GoogleMap} példány segítségével a térképhez adhatjuk a saját pozíciót lekérő gombot vagy megadhatjuk a térkép nézetének típusát.

\subsection*{Útvonaltervező}
\label{planner}
A felhasználó az Útvonaltervezés menüpontot kiválasztva Veszprém városán belül két tetszőleges hely között tervezhet közlekedési járatokat is alapul véve.
Ehhez meg kell adnia a kiindulási és érkezési pontokat.
Ezt megteheti úgy, hogy a saját pozícióját megadva automatikusan kitöltődik az indulási pont és már csak az érkezési helyet kell megadni, vagy mindkettőt manuálisan kell felvinnie.
A felvitelt \Highlight{SupportPlaceAutocompleteFragment}-en keresztül teheti meg a felhasználó.
Ahogy a felhasználó elkezdi beírni a helyszínt az \Highlight{SupportPlaceAutocompleteFragment} automatikus kiegészíti és javaslatokat tesz.
Annak érdekében, hogy a kevésbé releváns helyeket ne ajánlja fel, meg lehet adni egy területet, melyben található helyneveket előnyben részesítse a kiegészítés alkalmával.
Az előnyben részesítendő területet a \Highlight{setBoundsBias} metódus segítségével jelölhetjük ki.

Ahhoz, hogy a két kijelölt hely között megkapjuk a lehetséges útvonalakat, le kell futtatnunk valamilyen útvonaltervező algoritmust.
A későbbi továbbfejlesztést elősegítendő létrehoztam egy \Highlight{IPlanner} nevű felületet, melynek egyetlen metódusa a \Highlight{calculate}.
A felület mellé elkészült még egy BasePlanner nevű absztrakt osztály is, amely megvalósítja a felületet.
A tényleges útvonaltervezést implementáló osztályoknak ebből kell leszármazniuk.
Az ősosztály rendelkezik minden olyan fontos információval, amire az útvonaltervezés közben szüksége lehet az algoritmusnak, például az indulási és érkezési pontok. 
Rendelkezik továbbá egy \Highlight{OnPlannerListener} nevű callback felülettel, melynek \Highlight{onPlannerFinished} metódusát akkor kell meghívni, amikor az algoritmus végzett a tervezéssel.

Elkészült egy \Highlight{AdvancePlanner} nevű útvonaltervező osztály, mely képes a két pont között útvonalat tervezni.
Tervezés közben számításba veszi a lehetséges útvonalak között, hogy mennyit kell a felhasználónak sétálni, mennyit kell utazni időben és távolságban, valamint hogy hányszor kell átszállnia.
Az algoritmus menete a következő:
\begin{enumerate}
	\item A két megadott helyhez megkeressük a hozzájuk közel található buszmegállókat.
	\item Ezután leellenőrizzük, hogy a két listában található-e olyan eset, amikor közvetlenül eljuthatunk a két ponthoz közeli megállókba egy járattal. 
	Amennyiben igen, ezeket a lehetőségeket hozzáadjuk a lehetséges útvonalakhoz.
	\item Ha nem található közvetlen járat, az átszállásos járatok vizsgálata történik meg.
\end{enumerate}

Az algoritmus eredményül egy olyan listát ad át a \Highlight{onPlannerFinished} metódusnak, melynek minden eleme több utasítást tartalmaz.
Négy fajta utasítást különböztet meg az alkalmazás: sétálás indulási ponttól megállóig, sétálás megállótól érkezési pontig, buszutazás és amennyiben szükséges átszállás esetén séta két megálló között.
Az algoritmus befejezése után egy új képernyő jelenik meg.
Itt megtekinthetőek az eredményül kapott javaslatok csoportokra bontva.
Jelenleg három csoport szerint vannak rendezve az útvonalak:
\begin{itemize}
	\item Legkevesebb utazási idő
	\item Legkevesebb gyaloglás
	\item Legkevesebb átszállás
\end{itemize}

Amint a felhasználó kiválasztja a számára optimális megoldást, visszatér az előző képernyőre, ahol már a kiválasztott útvonal vizuálisan is megjelenik, a térképen jelölve a gyaloglási útvonalat és a járat(ok) által érintett megállókat.
\newpage